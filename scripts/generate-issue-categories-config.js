#!/usr/bin/env node
/**
 * Generate Issue Categories Configuration from Database
 *
 * This script queries the database and generates a TypeScript configuration file
 * containing all issue categories and their options. This ensures the database
 * is the single source of truth for the taxonomy.
 *
 * Usage:
 *   node scripts/generate-issue-categories-config.js
 *
 * Output:
 *   shared/config/issue-categories-config.ts
 *
 * @module scripts/generate-issue-categories-config
 */

const fs = require('fs');
const path = require('path');
const db = require('../services/database-service');

/**
 * Query database for all categories and options
 * @returns {Promise<Object>} Categories with nested options
 */
async function fetchTaxonomyFromDatabase() {
    const query = `
        SELECT
            ic.id as category_id,
            ic.category_code,
            ic.category_name,
            ic.display_order as category_order,
            json_agg(
                json_build_object(
                    'id', io.id,
                    'code', io.option_code,
                    'name', io.option_name,
                    'displayOrder', io.display_order
                ) ORDER BY io.display_order
            ) FILTER (WHERE io.id IS NOT NULL) as options
        FROM issue_categories ic
        LEFT JOIN issue_options io ON ic.id = io.category_id AND io.is_active = true
        WHERE ic.is_active = true
        GROUP BY ic.id, ic.category_code, ic.category_name, ic.display_order
        ORDER BY ic.display_order;
    `;

    const result = await db.query(query);
    return result.rows;
}

/**
 * Generate TypeScript file content from taxonomy data
 * @param {Array} categories - Array of categories with options
 * @returns {string} TypeScript file content
 */
function generateTypeScriptConfig(categories) {
    const timestamp = new Date().toISOString();

    let content = `/**
 * Issue Categories Configuration
 *
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated: ${timestamp}
 * Source: Database (issue_categories, issue_options tables)
 *
 * This file is automatically generated from the database by:
 *   npm run generate:issue-config
 *
 * To add new categories or options:
 *   1. Add to database via migration
 *   2. Run: npm run generate:issue-config
 *   3. Commit the updated file
 *
 * @module shared/config/issue-categories-config
 */

/**
 * Issue Option Type
 */
export interface IssueOption {
    /** Unique option ID (UUID from database) */
    id: string;
    /** Option code (e.g., 'RatsMice', 'Bats') */
    code: string;
    /** Display name shown to users */
    name: string;
    /** Sort order within category */
    displayOrder: number;
}

/**
 * Issue Category Type
 */
export interface IssueCategory {
    /** Unique category ID (UUID from database) */
    id: string;
    /** Category code (e.g., 'vermin', 'insects') */
    code: string;
    /** Display name shown to users */
    name: string;
    /** Sort order in UI */
    displayOrder: number;
    /** Available options for this category */
    options: IssueOption[];
}

/**
 * All Issue Categories (from database)
 * ${categories.length} categories, ${categories.reduce((sum, cat) => sum + (cat.options ? cat.options.length : 0), 0)} total options
 */
export const ISSUE_CATEGORIES: IssueCategory[] = [\n`;

    // Generate each category
    categories.forEach((category, idx) => {
        const options = category.options || [];

        content += `    {\n`;
        content += `        id: '${category.category_id}',\n`;
        content += `        code: '${category.category_code}',\n`;
        content += `        name: '${category.category_name}',\n`;
        content += `        displayOrder: ${category.category_order},\n`;
        content += `        options: [\n`;

        // Generate options for this category
        options.forEach((option, optIdx) => {
            content += `            {\n`;
            content += `                id: '${option.id}',\n`;
            content += `                code: '${option.code}',\n`;
            content += `                name: '${option.name}',\n`;
            content += `                displayOrder: ${option.displayOrder}\n`;
            content += `            }${optIdx < options.length - 1 ? ',' : ''}\n`;
        });

        content += `        ]\n`;
        content += `    }${idx < categories.length - 1 ? ',' : ''}\n`;
    });

    content += `];\n\n`;

    // Add helper functions
    content += `/**
 * Get category by code
 * @param code - Category code
 * @returns Category or undefined
 */
export function getCategoryByCode(code: string): IssueCategory | undefined {
    return ISSUE_CATEGORIES.find(cat => cat.code === code);
}

/**
 * Get option by code within a category
 * @param categoryCode - Category code
 * @param optionCode - Option code
 * @returns Option or undefined
 */
export function getOptionByCode(categoryCode: string, optionCode: string): IssueOption | undefined {
    const category = getCategoryByCode(categoryCode);
    return category?.options.find(opt => opt.code === optionCode);
}

/**
 * Get all option codes for a category
 * @param categoryCode - Category code
 * @returns Array of option codes
 */
export function getCategoryOptionCodes(categoryCode: string): string[] {
    const category = getCategoryByCode(categoryCode);
    return category?.options.map(opt => opt.code) || [];
}

/**
 * Validate if a category code exists
 * @param code - Category code to validate
 * @returns true if valid
 */
export function isValidCategoryCode(code: string): boolean {
    return ISSUE_CATEGORIES.some(cat => cat.code === code);
}

/**
 * Validate if an option code exists for a category
 * @param categoryCode - Category code
 * @param optionCode - Option code
 * @returns true if valid
 */
export function isValidOptionCode(categoryCode: string, optionCode: string): boolean {
    return getOptionByCode(categoryCode, optionCode) !== undefined;
}

/**
 * Get all valid category codes
 * @returns Array of all category codes
 */
export function getAllCategoryCodes(): string[] {
    return ISSUE_CATEGORIES.map(cat => cat.code);
}
`;

    return content;
}

/**
 * Ensure directory exists
 * @param {string} dirPath - Directory path
 */
function ensureDirectoryExists(dirPath) {
    if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath, { recursive: true });
        console.log(`‚úÖ Created directory: ${dirPath}`);
    }
}

/**
 * Main execution
 */
async function main() {
    console.log('üîÑ Generating issue categories config from database...\n');

    try {
        // 1. Connect to database
        console.log('1Ô∏è‚É£  Connecting to database...');
        await db.connect();
        console.log('   ‚úÖ Connected\n');

        // 2. Fetch taxonomy data
        console.log('2Ô∏è‚É£  Fetching taxonomy from database...');
        const categories = await fetchTaxonomyFromDatabase();
        const totalOptions = categories.reduce((sum, cat) => sum + (cat.options ? cat.options.length : 0), 0);
        console.log(`   ‚úÖ Fetched ${categories.length} categories, ${totalOptions} options\n`);

        // 3. Generate TypeScript content
        console.log('3Ô∏è‚É£  Generating TypeScript config...');
        const tsContent = generateTypeScriptConfig(categories);
        console.log('   ‚úÖ Generated\n');

        // 4. Ensure output directory exists
        const outputDir = path.join(__dirname, '..', 'shared', 'config');
        const outputFile = path.join(outputDir, 'issue-categories-config.ts');

        console.log('4Ô∏è‚É£  Writing output file...');
        ensureDirectoryExists(outputDir);
        fs.writeFileSync(outputFile, tsContent, 'utf8');
        console.log(`   ‚úÖ Written to: ${outputFile}\n`);

        // 5. Print summary
        console.log('üìä Summary:');
        console.log(`   Categories: ${categories.length}`);
        console.log(`   Options: ${totalOptions}`);
        console.log(`   Output: shared/config/issue-categories-config.ts`);
        console.log(`   Size: ${(tsContent.length / 1024).toFixed(2)} KB\n`);

        console.log('‚úÖ Generation complete!\n');
        console.log('Next steps:');
        console.log('  1. Review the generated file');
        console.log('  2. Add to package.json scripts: "generate:issue-config": "node scripts/generate-issue-categories-config.js"');
        console.log('  3. Commit the generated file to git\n');

        process.exit(0);

    } catch (error) {
        console.error('\n‚ùå Error generating config:', error);
        console.error('\nStack trace:', error.stack);
        process.exit(1);
    }
}

// Run if called directly
if (require.main === module) {
    main();
}

module.exports = { fetchTaxonomyFromDatabase, generateTypeScriptConfig };
